/*********************
有一个由很多木棒构成的集合，每个木棒有对应的长度，请问能否用集合中的这些木棒以某个顺序首尾相连
构成一个面积大于0的简单多边形且所有木棒都要用上，简单多边形即不会自交的多边形。
初始集合是空的，有两种操作，要么给集合添加一个长度为 L 的木棒，要么删去集合中已经有的某个木棒。
每次操作结束后你都需要告知是否能用集合中的这些木棒构成一个简单多边形。

输入描述:
每组测试用例仅包含一组数据，每组数据第一行为一个正整数 n 表示操作的数量(1 ≤ n ≤ 50000)，
接下来有n行，每行第一个整数为操作类型 i (i ∈ {1,2})，第二个整数为一个长度 L(1 ≤ L ≤ 1,000,000,000)。
如果 i=1 代表在集合内插入一个长度为 L 的木棒，如果 i=2 代表删去在集合内的一根长度为 L 的木棒。
输入数据保证删除时集合中必定存在长度为 L 的木棒，且任意操作后集合都是非空的。

输出描述:
对于每一次操作结束有一次输出，如果集合内的木棒可以构成简单多边形，输出 "Yes" ，否则输出 "No"。

输入例子1:
5
1 1
1 1
1 1
2 1
1 2

输出例子1:
No
No
Yes
No
No

解题思路：
要组成多边形，要任意的一条边小于其余的边的和，也就是最大的边的长度<其他边的长度之和，
即：总长度-最大的边的长度>最大的边的长度
*************/
#include<iostream>
#include<list>
using namespace std;

int a,b;
int flag=0;
int main(){
	int n;
	list<int> r;
	list<int>::iterator rr;
	cin>>n;
	int sum=0;
	while(n)
	{
		flag=0;
		cin>>a>>b;
		if(a==1){
			r.push_back(b);
			sum+=b;
		}
		else{
			//r.remove(b);			    //会删除所有匹配的值
			r.remove_if([](int n){  //remove_if 加一个函数
				if(n==b&&flag==0){	  //定义一个flag 删除一次之后就为1 为1的时候返回false 就只删除一次就不会删除了
					flag=1;
					return true;
				}else
					return false;
			});
			sum-=b;
		}
		r.sort();
		int ok=0;
		if(r.size()>=3){
			if(sum-r.back()>r.back())
				ok=1;
		}
		if(ok==1){
			cout<<"Yes"<<endl;
		}
		else{
			cout<<"No"<<endl;
		}

		n--;
	}
	return 0;
}